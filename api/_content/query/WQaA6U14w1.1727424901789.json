{"_path":"/writings/vue-composition-api","_dir":"writings","_draft":false,"_partial":false,"_locale":"","title":"深入理解Vue 3 Composition API","description":"探索Vue 3 Composition API的强大功能和使用方法","published":"2024/03/18","tags":["Vue","JavaScript","前端开发","Composition API"],"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"深入理解vue-3-composition-api"},"children":[{"type":"text","value":"深入理解Vue 3 Composition API"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Vue 3的发布带来了许多激动人心的新特性,其中最引人注目的莫过于Composition API。这个新的API为我们提供了一种更灵活、更强大的方式来组织和重用组件逻辑。本文将深入探讨Composition API的核心概念、使用方法以及它如何改变我们的Vue开发体验。"}]},{"type":"element","tag":"h2","props":{"id":"什么是composition-api"},"children":[{"type":"text","value":"什么是Composition API?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Composition API是Vue 3引入的一个新的API集合,旨在解决Vue 2中Options API的一些限制。它允许我们使用导入的API函数来描述组件逻辑,而不是依赖于预定义的组件选项。这种方法提供了更好的代码组织、逻辑重用和类型推断。"}]},{"type":"element","tag":"h2","props":{"id":"为什么需要composition-api"},"children":[{"type":"text","value":"为什么需要Composition API?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在大型复杂的应用中,Options API可能会导致组件变得难以理解和维护。相关的逻辑可能分散在不同的选项中,使得代码难以追踪和重构。Composition API通过允许我们按照逻辑关系组织代码,解决了这个问题。"}]},{"type":"element","tag":"h2","props":{"id":"setup函数composition-api的入口"},"children":[{"type":"text","value":"setup函数:Composition API的入口"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"setup"}]},{"type":"text","value":"函数是Composition API的核心。它在组件创建之前执行,作为组合逻辑的入口点。在"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"setup"}]},{"type":"text","value":"中,我们可以定义响应式状态、计算属性、方法等,并将它们返回以供模板使用。"}]},{"type":"element","tag":"h3","props":{"id":"setup函数的基本结构"},"children":[{"type":"text","value":"setup函数的基本结构"}]},{"type":"element","tag":"pre","props":{"className":["language-vue"],"code":"<template>\n  <div>\n    <p>Count: {{ count }}</p>\n    <p>Double Count: {{ doubleCount }}</p>\n    <button @click=\"increment\">\n      Increment\n    </button>\n  </div>\n</template>\n\n<script setup>\nimport { computed, onMounted, ref } from 'vue'\n// 响应式状态\nconst count = ref(0)\n// 计算属性\nconst doubleCount = computed(() => count.value, 2)\n// 方法\nconst increment = () => {\n  count.value++\n}\n// 生命周期钩子\nonMounted(() => {\n  console.log('组件已挂载')\n})\n</script>\n","language":"vue","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<template>\n  <div>\n    <p>Count: {{ count }}</p>\n    <p>Double Count: {{ doubleCount }}</p>\n    <button @click=\"increment\">\n      Increment\n    </button>\n  </div>\n</template>\n\n<script setup>\nimport { computed, onMounted, ref } from 'vue'\n// 响应式状态\nconst count = ref(0)\n// 计算属性\nconst doubleCount = computed(() => count.value, 2)\n// 方法\nconst increment = () => {\n  count.value++\n}\n// 生命周期钩子\nonMounted(() => {\n  console.log('组件已挂载')\n})\n</script>\n"}]}]},{"type":"element","tag":"h2","props":{"id":"响应式系统的核心ref和reactive"},"children":[{"type":"text","value":"响应式系统的核心:ref和reactive"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Composition API引入了两个主要的响应式API:"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ref"}]},{"type":"text","value":"和"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"reactive"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"h3","props":{"id":"ref"},"children":[{"type":"text","value":"ref"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ref"}]},{"type":"text","value":"用于创建一个响应式的引用,可以包含任何类型的值"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"import { ref } from 'vue'\nconst count = ref(0)\nconsole.log(count.value) // 0\ncount.value++\nconsole.log(count.value) // 1\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"import { ref } from 'vue'\nconst count = ref(0)\nconsole.log(count.value) // 0\ncount.value++\nconsole.log(count.value) // 1\n"}]}]},{"type":"element","tag":"h3","props":{"id":"reactive"},"children":[{"type":"text","value":"reactive"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"reactive"}]},{"type":"text","value":"用于创建一个响应式对象,可以包含多个属性"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"import { reactive } from 'vue'\nconst state = reactive({ count: 0 })\nconsole.log(state.count) // 0\nstate.count++\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"import { reactive } from 'vue'\nconst state = reactive({ count: 0 })\nconsole.log(state.count) // 0\nstate.count++\n"}]}]},{"type":"element","tag":"h2","props":{"id":"计算属性和监听器"},"children":[{"type":"text","value":"计算属性和监听器"}]},{"type":"element","tag":"h3","props":{"id":"计算属性"},"children":[{"type":"text","value":"计算属性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"计算属性是根据其他响应式状态计算得出的值。它们在模板中使用,但不会在响应式数据流中引入新的响应式状态。"}]},{"type":"element","tag":"pre","props":{"className":["language-javascript"],"code":"import { computed, ref } from 'vue'\nconst count = ref(0)\nconst doubleCount = computed(() => count.value, 2)\nconsole.log(doubleCount.value) // 0\ncount.value++\nconsole.log(doubleCount.value) // 2\n","language":"javascript","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"import { computed, ref } from 'vue'\nconst count = ref(0)\nconst doubleCount = computed(() => count.value, 2)\nconsole.log(doubleCount.value) // 0\ncount.value++\nconsole.log(doubleCount.value) // 2\n"}]}]},{"type":"element","tag":"h3","props":{"id":"监听器"},"children":[{"type":"text","value":"监听器"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"监听器用于监听响应式状态的变化,并在变化时执行某些操作。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"什么是composition-api","depth":2,"text":"什么是Composition API?"},{"id":"为什么需要composition-api","depth":2,"text":"为什么需要Composition API?"},{"id":"setup函数composition-api的入口","depth":2,"text":"setup函数:Composition API的入口","children":[{"id":"setup函数的基本结构","depth":3,"text":"setup函数的基本结构"}]},{"id":"响应式系统的核心ref和reactive","depth":2,"text":"响应式系统的核心:ref和reactive","children":[{"id":"ref","depth":3,"text":"ref"},{"id":"reactive","depth":3,"text":"reactive"}]},{"id":"计算属性和监听器","depth":2,"text":"计算属性和监听器","children":[{"id":"计算属性","depth":3,"text":"计算属性"},{"id":"监听器","depth":3,"text":"监听器"}]}]}},"_type":"markdown","_id":"content:1.writings:vue-composition-api.md","_source":"content","_file":"1.writings/vue-composition-api.md","_stem":"1.writings/vue-composition-api","_extension":"md"}